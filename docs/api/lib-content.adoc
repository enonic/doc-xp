= Content API
:toc: right
:imagesdir: ../images

Functions to find and manipulate content.

== Usage

Add the following to your `build.gradle` file:

[source,groovy]
----
dependencies {
  include "com.enonic.xp:lib-content:${xpVersion}"
}
----

Add the `import` statement to your controller:

[source,typescript]
----
import contentLib from '/lib/xp/content';
----

You are now ready to use the API.

== Constants

=== CONTENT_ROOT_PATH
Variable of type NodePath describing content node root path.
[.lead]
Usage

[source,typescript]
----
import {CONTENT_ROOT_PATH} from '/lib/xp/content';

const myRoot = CONTENT_ROOT_PATH; // NodePath.create( "/content" ).build()
----

=== ARCHIVE_ROOT_PATH
Variable of type NodePath describing archive node root path.


[.lead]
Usage

[source,typescript]
----
import {ARCHIVE_ROOT_PATH} from '/lib/xp/content';

const myRoot = ARCHIVE_ROOT_PATH; // NodePath.create( "/archive" ).build()
----

== Functions

=== addAttachment

Adds an attachment to an existing content.

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| key | string | | Path or id to the content
| name | string | | Attachment name
| mimeType | string | | Attachment content type
| label | string | <optional> | Attachment label
| data | object | <optional> | Stream with the binary data for the attachment
|===

[.lead]
Examples

[source,typescript]
----
import {addAttachment} from '/lib/xp/content';

// Adds an attachment.
addAttachment({
    key: '/mySite/mycontent',
    name: 'image',
    mimeType: 'image/png',
    label: 'photo',
    data: dataStream
});
----

=== archive
image:xp-780.svg[XP 7.8.0,opts=inline]

Archives a content

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| сontent | string | Path or id of the content to be archived
|===

[.lead]
Returns

*string[]* : List with ids of the contents that were archived

[.lead]
Examples
[source,typescript]
----
import {archive} from '/lib/xp/content';

// Archive content by path.
const result1 = archive({
    content: '/path/to/mycontent',
});

log.info('Archived content ids: %s', result1.join(','));

// Archive content by id.
const result2 = archive({
    content: 'my-content-id'
});

log.info('Archived content ids: %s', result2.join(','));
----

=== create

Creates a content.

Either `name` or `displayName` (or both) must be specified. When `name` is not set, the system will auto-generate a name based on the `displayName`, by lower-casing and replacing certain characters. If there is already a content with the auto-generated name, a suffix will be added to `name` in order to make it unique.

To create a content where `name` is not important and there could be multiple instances under the same parent content, skip the `name` parameter and specify a `displayName` instead.

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Default| Description
| name | string | <optional> | | Name of content
| parentPath | string | | | Path to place content under
| displayName | string | <optional> | | Display name. Default is same as name
| requireValid | boolean | <optional> | true | The content has to be valid, according to the content type, to be created. If requireValid=true and the content is not strictly valid, an error will be thrown
| refresh | boolean | <optional> | true | If refresh is true, the created content will to be searchable through queries immediately, else within 1 second. Since there is a performance penalty doing this refresh, refresh should be set to false for bulk operations
| contentType | string | | | Content type to use
| language | string | <optional> | | The language tag representing the content’s locale
| childOrder | string | <optional> | | Default ordering of children when doing getChildren if no order is given in query
| data | object | | | Actual content data
| page | object | <optional> | | content <<PageType, page>>
| x | object | <optional> | | eXtra data to use
| workflow | object | <optional> | | Workflow information to use. Default has state READY and empty check list.
|===

[.lead]
Returns

*object* : Content created as JSON

[.lead]
Examples

[source,typescript]
----
import {create} from '/lib/xp/content';

// Creates a content.
const result1 = create({
    name: 'mycontent',
    parentPath: '/a/b',
    displayName: 'My Content',
    contentType: 'test:myContentType',
    language: 'es',
    data: {
        a: 1,
        b: 2,
        c: ['1', '2'],
        d: {
            e: {
                f: 3.6,
                g: true
            }
        }
    },
    x: {
        "com-enonic-myapplication": {
            myschema: {
                a: 1
            }
        }
    },
    workflow: {
        state: 'PENDING_APPROVAL',
        checks: {
            'Review by lawyer': 'PENDING'
        }
    },
});

log.info('Content created with id %s', result1._id);
----

[source,typescript]
----
import {create} from '/lib/xp/content';

// Check if content already exists.
try {
    const result2 = create({
        name: 'mycontent',
        parentPath: '/a/b',
        displayName: 'My Content',
        contentType: 'test:myContentType',
        data: {}
    });

    log.info('Content created with id %s', result2._id);

} catch (e) {
    if (e.code == 'contentAlreadyExists') {
        log.error('There is already a content with that name');
    } else {
        log.error('Unexpected error: %s', e.message);
    }
}
----

[source,typescript]
----
// Content created.
const expected = {
    _id: "123456",
    _name: "mycontent",
    _path: "/a/b/mycontent",
    creator: "user:system:anonymous",
    createdTime: "1975-01-08T00:00:00Z",
    type: "test:myContentType",
    displayName: "My Content",
    hasChildren: false,
    language: "es",
    valid: false,
    data: {
        a: 1,
        b: 2,
        c: [
            "1",
            "2"
        ],
        d: {
            e: {
                f: 3.6,
                g: true
            }
        }
    },
    x: {
        "com-enonic-myapplication": {
            myschema: {
                a: 1
            }
        }
    },
    page: {},
    attachments: {},
    publish: {}
};
----

=== createMedia

Creates a media content

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Default| Description
| name | string | <optional> | | Name of content
| parentPath | string | <optional> | / | Path to place content under
| mimeType | string | <optional> | | Mime-type of the data
| focalX | number | <optional> | | Focal point for X axis (if it's an image)
| focalY | number | <optional> | | Focal point for Y axis (if it's an image)
| data | | | | Data (as stream) to use
|===

[.lead]
Returns

*object* : Returns the created media content

[.lead]
Examples

[source,typescript]
----
import {createMedia} from '/lib/xp/content';

// Creates a media.
const result = createMedia({
    name: 'mycontent',
    parentPath: '/a/b',
    mimeType: 'text/plain',
    data: stream
});
----

[source,typescript]
----
// Media created.
const expected = {
    _id: "123456",
    _name: "mycontent",
    _path: "/a/b/mycontent",
    creator: "user:system:anonymous",
    createdTime: "1975-01-08T00:00:00Z",
    type: "base:unstructured",
    hasChildren: false,
    valid: false,
    data: {},
    x: {},
    page: {},
    attachments: {},
    publish: {}
};
----

=== updateMedia

Modifies a media content

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Default| Description
| key | string | | | Path or id of the media content
| name | string | | | Name of the media content
| data | | | | Media data (as a stream)
| mimeType | string | <optional> | | Mime-type of the data
| focalX | number | <optional> | | Focal point for X axis (if content is an image)
| focalY | number | <optional> | | Focal point for Y axis (if content is an image)
| caption | string | <optional> | | Caption
| artist | string \| string[]  | <optional> | | Artist
| copyright | string | <optional> | | Copyright
| tags | string \| string[] | <optional> | | Tags
| workflowInfo | object | <optional> | | Workflow state (default: READY).

|===

[.lead]
Returns

*object* : Returns the modified media content

[.lead]
Examples

[source,typescript]
----
import {updateMedia} from '/lib/xp/content';

// Modifies a media.
const result = updateMedia({
    key: '/a/b/mycontent',
    name: 'mycontent',
    data: stream,
    artist: ['Artist 1', 'Artist 2'],
    caption: 'Caption',
    copyright: 'Copyright',
    mimeType: 'text/plan',
    tags: ['tag1', 'tag2']
});
----

[source,typescript]
----
// Modified media.
const expected = {
    _id: "123456",
    _name: "myMedia",
    _path: "/a/b/myMedia",
    creator: "user:system:anonymous",
    createdTime: "1975-01-08T00:00:00Z",
    type: "base:unstructured",
    hasChildren: false,
    valid: false,
    data: {
        caption: "Caption",
        artist: [
            "Artist 1",
            "Artist 2"
        ],
        copyright: "Copyright",
        mimeType: "text/plan",
        tags: [
            "tag1",
            "tag2"
        ]
    },
    x: {},
    page: {},
    attachments: {},
    publish: {},
    workflow: {
        state: "READY",
        checks: {}
    }
};
----

=== delete

Deletes a content

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| key | string | Path or id to the content
|===

[.lead]
Returns

*boolean* : `true` if deleted, `false` otherwise

[.lead]
Examples

[source,typescript]
----
import {delete as deleteContent} from '/lib/xp/content';

// Deletes a content by path.
const result = deleteContent({
    key: '/features/js-libraries/mycontent'
});

if (result) {
    log.info('Content deleted');
} else {
    log.info('Content was not found');
}
----

=== duplicate

image:xp-7120.svg[XP 7.12.0,opts=inline] Duplicates a content.

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,1%,1%,96%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Default | Description
| contentId | string | | | Id of the content.
| workflow | Object | <optional> | ```{
state: "READY",
checks: {}
}``` | Workflow state.
| includeChildren |  boolean | <optional> | true | Indicates that children contents must be duplicated, too. Ignored if `variant=true`.
| variant | boolean | <optional> | false | Indicates that duplicated content is a variant.
| parent | string | <optional> | | Destination parent path. By default, a duplicated content will be added as a sibling of the source content.
| name | string | <optional> | | New content name.
|===

[.lead]
Returns summary of the content duplicate.

*object* : Summary of the content duplicate.

[.lead]
Examples

Duplicate a content
[source,typescript]
----
import {duplicate} from '/lib/xp/content';

// Duplicate content by id
const result = duplicate({
    contentId: '79e21db0-5b43-45ce-b58c-6e1c420b22bd',
    includeChildren: false,
});

// Summary of the duplicated content.
const expected = {
    contentName: "sourcecontentname-copy",
    sourceContentPath: "/path/to/duplicated-content",
    duplicatedContents: [
        "duplicated-content-id"
    ]
};
----

Create a variant
[source,typescript]
----
import {duplicate} from '/lib/xp/content';

// Create a variant of the content
const result = duplicate({
    contentId: '79e21db0-5b43-45ce-b58c-6e1c420b22bd',
    variant: true,
    name: 'variant-name'
});

const expected = {
    contentName: "variant-name",
    sourceContentPath: "/path/to/variant-name",
    duplicatedContents: [
        "variant-content-id"
    ]
}
----

=== exists

Checks if a content exists in the current context.

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| key | string | Path or id to the content
|===

[.lead]
Returns

*boolean* : `true` if exists, `false` otherwise

[.lead]
Examples

[source,typescript]
----
import {exists} from '/lib/xp/content';

// Checking if a content exists
const result = exists({
    key: '/path/to/mycontent'
});

if (result) {
    log.info('Content exists');
} else {
    log.info('Content does not exist');
}
----


=== get

Returns a content

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="35%,1%,1%,63%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| key | string | | Path or id to the parent content
| versionId image:xp-720.svg[XP 7.2.0,opts=inline] | string | <optional> | Content version id
|===

[.lead]
Returns

*object* : The content (as JSON) fetched from the repository

[.lead]
Examples

[source,typescript]
----
import {get as getContentByKey} from '/lib/xp/content';

// Gets a single content by path.
const result = getContentByKey({
    key: '/path/to/mycontent'
});

if (result) {
    log.info('Display Name = %s', result.displayName);
} else {
    log.info('Content was not found');
}
----

[source,typescript]
----
// Content as it is returned.
const expected = {
    _id: "123456",
    _name: "mycontent",
    _path: "/path/to/mycontent",
    creator: "user:system:admin",
    modifier: "user:system:admin",
    createdTime: "1970-01-01T00:00:00Z",
    modifiedTime: "1970-01-01T00:00:00Z",
    type: "base:unstructured",
    displayName: "My Content",
    hasChildren: false,
    language: "en",
    valid: true,
    childOrder: "_ts DESC, _name ASC",
    data: {
        myfield: "Hello World"
    },
    x: {},
    page: {},
    attachments: {
        "logo.png": {
            name: "logo.png",
            label: "small",
            size: 6789,
            mimeType: "image/png"
        },
        "document.pdf": {
            name: "document.pdf",
            size: 12345,
            mimeType: "application/pdf"
        }
    },
    publish: {}
};
----

=== getAttachments

This function returns a content attachments

[.lead]
*Parameters:*

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name  | Type   | Description
| key | string | Path or id to the content
|===

[.lead]
Returns

*object* : An object with all the attachments stored in the content, where the key is the attachment name. Or null if the content was not found.

[.lead]
Examples

[source,typescript]
----
// Attachments returned.
const expected = {
    "logo.png": {
        name: "logo.png",
        label: "small",
        size: 6789,
        mimeType: "image/png"
    },
    "document.pdf": {
        name: "document.pdf",
        size: 12345,
        mimeType: "application/pdf"
    }
};
----

=== getAttachmentStream

This function returns a data-stream for the specified content attachment

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| key | string | Path or id to the content
| name | string | Attachment name
|===

[.lead]
Returns

*object* : Stream of the attachment data

[.lead]
Examples

[source,typescript]
----
import {getAttachmentStream} from '/lib/xp/content';

// Get stream for attachment.
const stream = getAttachmentStream({
    key: '/a/b/mycontent',
    name: 'document.pdf'
});
----

=== getChildren

Fetches children of a content

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Default| Description
| key | string | | | Path or id to the parent content
| start | number | <optional> | 0 | Start index (used for paging)
| count | number | <optional> | 10 | Number of contents to fetch
| sort | string | <optional> | | Sorting expression
|===

[.lead]
Returns

*object* : An array of child items (as JSON) fetched from the repository

[.lead]
Examples

[source,typescript]
----
import {getChildren} from '/lib/xp/content';

// Returns the children of specified path.
const result = getChildren({
    key: '/path/to',
    start: 0,
    count: 2,
    sort: '_modifiedTime ASC'
});

log.info('Found %s number of contents', result.total);

result.hits.forEach((content) => {
  log.info('Content %s loaded', content._name);
});
----

[source,typescript]
----
// Result set returned.
const expected = {
    total: 20,
    count: 2,
    hits: [
        {
            _id: "id1",
            _name: "name1",
            _path: "/a/b/name1",
            creator: "user:system:admin",
            modifier: "user:system:admin",
            createdTime: "1970-01-01T00:00:00Z",
            modifiedTime: "1970-01-01T00:00:00Z",
            type: "base:unstructured",
            displayName: "My Content 1",
            hasChildren: false,
            valid: false,
            data: {},
            x: {},
            page: {},
            attachments: {},
            publish: {}
        },
        {
            _id: "id2",
            _name: "name2",
            _path: "/a/b/name2",
            creator: "user:system:admin",
            modifier: "user:system:admin",
            createdTime: "1970-01-01T00:00:00Z",
            modifiedTime: "1970-01-01T00:00:00Z",
            type: "base:unstructured",
            displayName: "My Content 2",
            hasChildren: false,
            valid: false,
            data: {},
            x: {},
            page: {},
            attachments: {},
            publish: {}
        }
    ]
};
----



=== getOutboundDependencies

image:xp-720.svg[XP 7.2.0,opts=inline]

Returns the list of content items that are outbound dependencies of specified content.

[.lead]
*Parameters:*

An object with the following properties:

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| key | string | Path or id to the content
|===

[.lead]
Returns

*string[]* : List with ids of dependent content items


[.lead]
Examples

[source,typescript]
----
import {getOutboundDependencies} from '/lib/xp/content';

// Gets outbound dependencies of content by its Id.
const result = getOutboundDependencies({
    key: '/features/js-libraries/mycontent'
});

if (result) {
    log.info('Outbound dependencies: %s', JSON.stringify(result, null, 4));
} else {
    log.info('Outbound dependencies were not found');
}
----

=== getPermissions

Returns content permissions

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| key | string | Path or id to the content
|===

[.lead]
Returns

*object* : Content permissions

[.lead]
Examples

[source,typescript]
----
import {getPermissions} from '/lib/xp/content';

// Return permissions for content by path.
const result = getPermissions({
    key: '/features/js-libraries/mycontent'
});

if (result) {
    log.info('Content inherits permissions: %s', result.inheritPermissions);
} else {
    log.info('Content not found');
}
----

[source,typescript]
----
// Permissions returned.
const expected = {
    permissions: [
        {
            principal: "user:system:anonymous",
            allow: [
                "READ"
            ],
            deny: []
        }
    ]
};
----

=== getSite

Returns the parent site of a content

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| key | string | Path or id to the content
|===

[.lead]
Returns

*object* : The current site as JSON

[.lead]
Examples

[source,typescript]
----
import {getSite} from '/lib/xp/content';

// Returns content's parent site
const result = getSite({
    key: '/path/to/mycontent'
});
log.info('Site name = %s', result._name);
----

[source,typescript]
----
// Site data returned.
const expected = {
    _id: "100123",
    _name: "my-content",
    _path: "/my-content",
    type: "base:unstructured",
    hasChildren: false,
    valid: false,
    data: {
        siteConfig: {
            applicationKey: "myapplication",
            config: {
                Field: 42
            }
        }
    },
    x: {},
    page: {},
    attachments: {},
    publish: {}
};
----

=== getSiteConfig

Returns configuration of a specified application assigned to the site of a content

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| key | string | Path or id to the content
| applicationKey | string | Application key
|===

[.lead]
Returns

*object* : App config (as JSON)

[.lead]
Examples

[source,typescript]
----
import {getSiteConfig} from '/lib/xp/content';

// Returns config of the content's parent site
const result = getSiteConfig({
    key: '/path/to/mycontent',
    applicationKey: app.name
});
log.info('Field value for the site config = %s', result.Field);
----

[source,typescript]
----
// Site config returned.
const expected = {
    Field: 42
};
----

=== getType

Returns properties and icon of the specified content type

[.lead]
*Parameters:*

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name  | Type   | Description
| name | string | Name of the content type, as 'app:name' (e.g. 'com.enonic.myapp:article')
|===

[.lead]
Returns

*<<ContentType>>* : The content type object if found, or `null` otherwise. See ContentType type definition below

[.lead]
Examples

[source,typescript]
----
import {getType} from '/lib/xp/content';

// Get a content type by name
const contentType = getType('com.enonic.myapp:person');
----

[source,typescript]
----
// Content type returned:
const expected = {
    name: "com.enonic.myapp:person",
    displayName: "Person",
    description: "Person content type",
    superType: "base:structured",
    abstract: false,
    final: true,
    allowChildContent: true,
    displayNameExpression: "${name}",
    icon: {
        mimeType: "image/png",
        modifiedTime: "2016-01-01T12:00:00Z"
    },
    form: [
        {
            formItemType: "Input",
            name: "name",
            label: "Full name",
            maximize: true,
            inputType: "TextLine",
            occurrences: {
                maximum: 1,
                minimum: 1
            },
            config: {}
        },
        {
            formItemType: "Input",
            name: "title",
            label: "Photo",
            helpText: "Person photo",
            maximize: true,
            inputType: "ImageSelector",
            occurrences: {
                maximum: 1,
                minimum: 1
            },
            config: {}
        },
        {
            formItemType: "Input",
            name: "bio",
            label: "Bio",
            maximize: true,
            inputType: "HtmlArea",
            occurrences: {
                maximum: 1,
                minimum: 1
            },
            config: {}
        },
        {
            formItemType: "Input",
            name: "birthdate",
            label: "Birth date",
            maximize: true,
            inputType: "Date",
            occurrences: {
                maximum: 1,
                minimum: 0
            },
            config: {}
        },
        {
            formItemType: "Input",
            name: "email",
            label: "Email",
            helpText: "Email address",
            maximize: true,
            inputType: "TextLine",
            occurrences: {
                maximum: 1,
                minimum: 1
            },
            config: {
                regexp: [
                    {
                        value: "^[^@]+@[^@]+\\.[^@]+$"
                    }
                ]
            }
        },
        {
            formItemType: "Input",
            name: "nationality",
            label: "Nationality",
            maximize: true,
            inputType: "ContentSelector",
            occurrences: {
                maximum: 1,
                minimum: 0
            },
            config: {
                allowContentType: [
                    {
                        value: "com.enonic.myapp:country"
                    }
                ]
            }
        }
    ]
};
----

[source,typescript]
----
import {getType} from '/lib/xp/content';

// Get a content type icon
const ct = getType('com.enonic.myapp:person');
const icon = ct.icon;
return {
    body: icon.data,
    contentType: icon.mimeType
};
----

=== getTypes

Returns the list of all the content types currently registered in the system

[.lead]
Returns

*<<ContentType>>[]* : Array with all the content types found. See ContentType type definition below

[.lead]
Examples

[source,typescript]
----
import {getTypes} from '/lib/xp/content';

// Gets the list of all content types in the system
const contentTypes = getTypes();

log.info('%s content types found:', contentTypes.length);
contentTypes.forEach(({displayName,name,superType}) => {
    if (superType === 'base:structured') {
        log.info('%s - %s', name, displayName);
    }
});
----

=== update

Update a content

NOTE: Properties starting with `_` may not be modified using this function. To rename or move a content (ie to change the `_name` property), use the <<move, move function>> instead.

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Default| Description
| key | string | | | Path or id to the content
| editor | function | | | Editor callback function
| requireValid | boolean | <optional> | true | The content has to be valid (according to the content type) to be updated. If `requireValid=true` and the content is not strictly valid, an error will be thrown
|===

[.lead]
Returns

*object* : Modified content as JSON

[.lead]
Examples

[source,typescript]
----
import {update} from '/lib/xp/content';

// Editor to call for content.
function editor(c) {
    c.displayName = 'Modified';
    c.language = 'en';
    c.data.myCheckbox = false;
    c.data["myTime"] = "11:00";
    c.publish.from = "2016-11-03T10:01:34Z";
    c.workflow.state = "READY";
    return c;
}

// Update content by path
const result = update({
    key: '/a/b/mycontent',
    editor: editor
});

if (result) {
    log.info('Content modified. New title is %s', result.displayName);
} else {
    log.info('Content not found');
}
----

[source,typescript]
----
// Content modified.
const expected = {
    _id: "123456",
    _name: "mycontent",
    _path: "/path/to/mycontent",
    creator: "user:system:admin",
    modifier: "user:system:admin",
    createdTime: "1970-01-01T00:00:00Z",
    modifiedTime: "1970-01-01T00:00:00Z",
    type: "base:unstructured",
    displayName: "Modified",
    hasChildren: false,
    language: "en",
    valid: true,
    childOrder: "_ts DESC, _name ASC",
    data: {
        myfield: "Hello World",
        myCheckbox: "false",
        myTime: "11:00"
    },
    x: {},
    page: {},
    attachments: {
        "logo.png": {
            name: "logo.png",
            label: "small",
            size: 6789,
            mimeType: "image/png"
        },
        "document.pdf": {
            name: "document.pdf",
            size: 12345,
            mimeType: "application/pdf"
        }
    },
    publish: {
        from: "2016-11-03T10:01:34Z"
    },
    workflow: {
        state: "READY",
        checks: {}
    }
};
----

=== patch

Patches a content

[WARNING]
====
This is a low-level and potentially dangerous operation.

It should be used with caution. Access is restricted to users with `admin` or `cms.admin` roles.
====

[%header,cols="1%,1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Default| Description
| key | string | | | Path or id to the content
| patcher | function | | | Patcher callback function
| branches | string[] | <optional> | false | A list of branches to patch. +
* If not provided or empty, the content in the current branch will be patched. +
* If one branch is listed, the patch occurs in that specific branch. +
* If multiple branches are listed: +
1.  The patch is applied to the *first* branch in the list. +
2.  For each subsequent branch in the list: +
* If its content version is identical to the *original* (pre-patch) version from any processed branch, it is simply switched to point to the new, patched version. +
* If its content version is *different*, the patch is applied to it separately.
| skipSync | boolean | <optional> | false | If true, skip synchronization of the content in children projects after patching
| attachments | object | <optional> | | Object for managing content attachments. Contains optional arrays: <<createAttachments_details, \`createAttachments` (add new)>>, <<modifyAttachments_details, \`modifyAttachments` (update existing)>> and \`removeAttachments` (a string array with attachment names to remove) .
|===

`patcher` is a function that receives the current content as parameter and must return the modified content. A list of supported fields that can be patched is provided below.

[.lead]
*Patchable Fields:*

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description

| displayName | string | The display name of the content.
| language | string | The language tag representing the content’s locale.
| childOrder | string | String defining the sort order of children.
| manualOrderValue | number | Numeric value used for manual sorting across siblings (when parent's childOrder is manual).
| valid | boolean | Sets the content's validity status.

| data | object | A JSON object containing the main data (properties) of the content, according to its content type.
| page | object | A JSON object describing the <<PageType, page>> configuration including regions and components.
| x | object | A JSON object containing extra data (x-data) associated with the content.

| owner | string | The owner of the content. Must be a PrincipalKey string.
| creator | string | The creator of the content. Must be a PrincipalKey string.
| createdTime | string | The creation timestamp. Must be an ISO 8601 formatted string.
| modifier | string | The principal who last modified the content. Must be a PrincipalKey string.
| modifiedTime | string | The last modified timestamp. Must be an ISO 8601 formatted string.
| archivedBy | string | The principal who archived the content. Must be a PrincipalKey string.
| archivedTime | string | The archival timestamp. Must be an ISO 8601 formatted string.

| publish | object | A JSON object containing publishing information.
| workflow | object | A JSON object containing <<WorkflowInfoType, workflow>> state information.

| inherit | string[] | An array of strings specifying which properties to inherit from the parent (e.g., ["owner", "language"]).
| variantOf | string | The ContentId (as a string) of the content this item is a variant of (used for localization).
| processedReferences | string[] | An array of ContentId strings that this content references.
| validationErrors | <<ValidationErrorType, ValidationError>>[] | An array of objects describing validation errors.
| originProject | string | The name of the project this content was inherited from.
| originalParentPath | string | The original parent path in the parent project.
| originalName | string | The original name in the parent project.
|===

[[createAttachments_details]]
[.lead]
*createAttachments:*
An object with the following keys and their values:

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes|  Description
| name | string | | Name of the attachment to create
| mimeType | string | <optional> | Mime-type of the data
| label | string | <optional> | Label of the attachment
| textContent | string | <optional> | Text content to set
| sha512 | string | <optional> | SHA-512 hash of the data
| size | number | <optional> | Size of the data in bytes
|===

[[modifyAttachments_details]]
[.lead]
*modifyAttachments:*
An object with the following keys and their values:

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name        | Type    | Attributes |  Description
| name        | string         |             | Name of the attachment to modify
| mimeType    | string         | <optional> | Mime-type of the data
| label       | string         | <optional> | Label of the attachment
| textContent | string         | <optional> | Text content to set
| data        | object(stream) | <optional> | Data (as stream) to use
|===

[.lead]
Examples

.Patching archival info.
[source,typescript]
----
import {patch} from '/lib/xp/content';
function patcher(c) {
    c.archivedBy = 'user:system:admin';
    c.archivedTime = new Date().toISOString();
    return c;
}

const result = patch({
    key: '/a/b/mycontent',
    patcher: patcher
});

----

.Patching content's attachments.
[source,typescript]
----
import {patch} from '/lib/xp/content';
import {newStream} from '/lib/xp/io';

// Patcher function to modify content.
function patcher(c) {
    c.displayName = 'Patched Content';
    c.data.myField = 'New Value';
    return c;
}
// Patch content by path
const result = patch({
    key: '/a/b/mycontent',
    patcher: patcher,
    branches: ['draft', 'master'],
    attachments: {
        createAttachments: [
            {
                name: 'new-attachment.txt',
                mimeType: 'text/plain',
                data: newStream('Hello World')
            }
        ],
        modifyAttachments: [
            {
                name: 'existing-attachment.txt',
                mimeType: 'text/plain',
                label: 'updated-label'
            }
        ],
        removeAttachments: [
            'old-attachment.txt'
        ]
    }
});
----

=== move
[[move]]

Renames a content or moves it to a new path

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| source | string | Path or id of the content to be moved or renamed
| target | string | New path or name for the content. If the target ends in slash '/', it specifies the parent path where to be moved. Otherwise it means the new desired path or name for the content
|===

[.lead]
Returns

*object* : The content that was moved or renamed

[.lead]
Examples

[source,typescript]
----
import {move} from '/lib/xp/content';

// Rename content by path. Keeps same parent.
const content1 = move({
    source: '/my-site/my-content-name',
    target: 'new-name'
});

log.info('New path: %s', content1._path); // '/my-site/new-name'
----

[source,typescript]
----
import {move} from '/lib/xp/content';

// Move content by path. New parent path, keeps same name.
const content2 = move({
    source: '/my-site/my-content-name',
    target: '/my-site/folder/'
});

log.info('New path: %s', content2._path); // '/my-site/folder/my-content-name'
----

[source,typescript]
----
import {move} from '/lib/xp/content';

// Move content by id to new path. New parent path, keeps same name.
const content3 = move({
    source: '8d933461-ede7-4dd5-80da-cb7de0cd7bba',
    target: '/my-site/folder/'
});

log.info('New path: %s', content3._path); // '/my-site/folder/my-content-name'
----

[source,typescript]
----
import {move} from '/lib/xp/content';

// Move and rename content.
const content4 = move({
    source: '/my-site/my-content-name',
    target: '/my-site/folder/new-name'
});

log.info('New path: %s', content4._path); // '/my-site/folder/new-name'
----

[source,typescript]
----
import {move} from '/lib/xp/content';

// Handle error if target already exists.
try {
    const content5 = move({
        source: '/my-site/my-content-name',
        target: '/my-site/folder/existing-content'
    });

} catch (e) {
    if (e.code == 'contentAlreadyExists') {
        log.error('There is already a content in the target specified');
    } else {
        log.error('Unexpected error: %s', e.message);
    }
}
----

=== publish

Publishes content to the master branch

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Default| Description
| keys | string[] | | | List of all content keys(path or id) that should be published
| schedule | <<ScheduleParams>> | <optional> | | Schedule publishing
| excludeChildrenIds | string[] | <optional> | | List of content keys whose descendants should be excluded from publishing
| includeDependencies | boolean | <optional> | true | Whether all related content should be included when publishing content
| sourceBranch | string | | | _Not in use from_ image:xp-7120.svg[XP 7.12.0,opts=inline]. The branch where the content to be published is stored.
| targetBranch | string | | | _Not in use since_ image:xp-7120.svg[XP 7.12.0,opts=inline]. The branch to which the content should be published. Technically, publishing is just a move from one branch to another, and publishing user content from master to draft is therefore also valid usage of this function, which may be practical if user input to a web-page is stored on master
|===

==== ScheduleParams

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| from | string | <optional> | Time from which the content is considered published. Defaults to the time of publishing
| to | string | <optional> | Time until which the content is considered published
|===


[.lead]
Returns

*object* : Status of the publish operation as JSON

[.lead]
Examples

[source,typescript]
----
import {publish} from '/lib/xp/content';

// Publish content by path or key
const result = publish({
    keys: ['/mysite/somepage', '79e21db0-5b43-45ce-b58c-6e1c420b22bd'],
    sourceBranch: 'draft',
    targetBranch: 'master',
    schedule: {
        from: new Date().toISOString(),
        to: '2018-01-01T13:37:00.000Z'
    },
    includeDependencies: false
});

if (result) {
    log.info('Pushed %s content.', result.pushedContents.length);
    log.info('Deleted %s content.1, result.deletedContents.length);
    log.info('Content that failed operation: %s', result.failedContents.length);
} else {
    log.info('Operation failed.');
}
----

[source,typescript]
----
// Content published.
const expected = {
    pushedContents: [
        "d7ad428b-eae2-4ff1-9427-e8e8a8a3ab23",
        "9f5b0db0-38f9-4e81-b92e-116f25476b1c",
        "e1f57280-d672-4cd8-b674-98e26e5b69ae"
    ],
    deletedContents: [ // Removed from 7.12.0
        "45d67001-7f2b-4093-99ae-639be9fdd1f6"
    ],
    failedContents: [
        "79e21db0-5b43-45ce-b58c-6e1c420b22bd"
    ]
};
----

=== query

Retrieves content using a query

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Default| Description
| start | number | <optional> | 0 | Start index (used for paging)
| count | number | <optional> | 10 | Number of contents to fetch
| query | string/object | | | Query string or <<../storage/dsl#, DSL>> expression
| filters | object | <optional> | | Filters to apply to query result
| sort | string/object | <optional> | | Sorting string or <<../storage/dsl#sort, DSL>> expression
| aggregations | string | <optional> | | Aggregations expression
| contentTypes | string[] | <optional> | | Content types to filter on
|===

[.lead]
Returns

*object* : Result of query

image:xp-750.svg[XP 7.5.0,opts=inline] If `sort` was specified, results will contain system meta properties `_sort` and `_score: null`, otherwise `_score`
 will have a relevant value.

[.lead]
Examples

[source,typescript]
----
import {query} from '/lib/xp/content';

// Query content using aggregations.
const result = query({
    start: 0,
    count: 2,
    sort: "modifiedTime DESC, geoDistance('data.location', '59.91,10.75', 'km')",
    query: "data.city = 'Oslo' AND fulltext('data.description', 'garden', 'AND') ",
    filters: {
        boolean: {
            must: [
                {
                    exists: {
                        field: "modifiedTime"
                    }
                },
                {
                    exists: {
                        field: "another"
                    }
                }
            ],
            mustNot: {
                hasValue: {
                    field: "myField",
                    values: [
                        "cheese",
                        "fish",
                        "onion"
                    ]
                }
            }
        },
        notExists: {
            field: "unwantedField"
        },
        ids: {
            values: ["id1", "id2"]
        }
    },
    contentTypes: [
        app.name + ":house",
        app.name + ":apartment"
    ],
    aggregations: {
        floors: {
            terms: {
                field: "data.number_floor",
                order: "_count asc"
            },
            aggregations: {
                prices: {
                    histogram: {
                        field: "data.price",
                        interval: 1000000,
                        extendedBoundMin: 1000000,
                        extendedBoundMax: 3000000,
                        minDocCount: 0,
                        order: "_key desc"
                    }
                }
            }
        },
        by_month: {
            dateHistogram: {
                field: "data.publish_date",
                interval: "1M",
                minDocCount: 0,
                format: "MM-yyyy"
            }
        },
        price_ranges: {
            range: {
                field: "data.price",
                ranges: [
                    {to: 2000000},
                    {from: 2000000, to: 3000000},
                    {from: 3000000}
                ]
            }
        },
        my_date_range: {
            dateRange: {
                field: "data.publish_date",
                format: "MM-yyyy",
                ranges: [
                    {to: "now-10M/M"},
                    {from: "now-10M/M"}
                ]
            }
        },
        price_stats: {
            stats: {
                field: "data.price"
            }
        }
    }
});

log.info('Found %s number of contents', result.total);

result.hits.forEach((content) => {
  log.info('Content %s found', content._name);
});
----

[source,typescript]
----
// Result set returned.
const expected = {
    total: 20,
    count: 2,
    hits: [
        {
            _id: "id1",
            _name: "name1",
            _path: "/a/b/name1",
            _sort: ["1970-01-01T00:00:00Z", 9279.647306690395],
            _score: null,
            creator: "user:system:admin",
            modifier: "user:system:admin",
            createdTime: "1970-01-01T00:00:00Z",
            modifiedTime: "1970-01-01T00:00:00Z",
            type: "base:unstructured",
            displayName: "My Content 1",
            hasChildren: false,
            valid: false,
            data: {},
            x: {},
            page: {},
            attachments: {},
            publish: {}
        },
        {
            _id: "id2",
            _name: "name2",
            _path: "/a/b/name2",
            _sort: [ "1970-01-01T00:00:00Z", 15964.050071707446],
            _score: null,
            creator: "user:system:admin",
            modifier: "user:system:admin",
            createdTime: "1970-01-01T00:00:00Z",
            modifiedTime: "1970-01-01T00:00:00Z",
            type: "base:unstructured",
            displayName: "My Content 2",
            hasChildren: false,
            valid: false,
            data: {},
            x: {},
            page: {},
            attachments: {},
            publish: {}
        }
    ],
    aggregations: {
        genders: {
            buckets: [
                {
                    key: "male",
                    docCount: 10
                },
                {
                    key: "female",
                    docCount: 12
                }
            ]
        },
        by_month: {
            buckets: [
                {
                    key: "2014-01",
                    docCount: 8
                },
                {
                    key: "2014-02",
                    docCount: 10
                },
                {
                    key: "2014-03",
                    docCount: 12
                }
            ]
        },
        price_ranges: {
            buckets: [
                {
                    key: "a",
                    docCount: 2,
                    to: 50
                },
                {
                    key: "b",
                    docCount: 4,
                    from: 50,
                    to: 100
                },
                {
                    key: "c",
                    docCount: 4,
                    from: 100
                }
            ]
        },
        my_date_range: {
            buckets: [
                {
                    key: "date range bucket key",
                    docCount: 2,
                    from: "2014-09-01T00:00:00Z"
                },
                {
                    docCount: 5,
                    from: "2014-10-01T00:00:00Z",
                    to: "2014-09-01T00:00:00Z"
                },
                {
                    docCount: 7,
                    to: "2014-11-01T00:00:00Z"
                }
            ]
        },
        item_count: {
            count: 5,
            min: 1,
            max: 5,
            avg: 3,
            sum: 15
        }
    }
};
----

=== removeAttachment

Removes an attachment from an existing content

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| key | string | Path or id to the content
| name | string \| string[] | Attachment name, or array of names
|===

[.lead]
Examples

[source,typescript]
----
import {removeAttachment} from '/lib/xp/content';

// Removes an attachment, by content path.
removeAttachment({key: '/mySite/mycontent', name: 'document'});
----

[source,typescript]
----
import {removeAttachment} from '/lib/xp/content';

// Removes multiple attachments, by content id.
removeAttachment({key: '3381d720-993e-4576-b089-aaf67280a74c', name: ['document', 'image']});
----

=== resetInheritance
image:xp-760.svg[XP 7.6.0,opts=inline]

Resets custom inheritance flags of a content item. For an item that was inherited from a parent content project/layer this action
will reset specified changes made inside a specified layer.

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| key | string | Path or id to the content
| projectName | string | A unique id of a Content Layer in which the inherited content item should be reset
| inherit | string[] | Array of inheritance flags (case-sensitive, all upper-case).
Supported values are: `CONTENT` (resets any customized content data), `PARENT` (resets item moved under a different parent),
`NAME` (resets renamed item), `SORT` (resets custom sorting).

|===

[.lead]
Examples

[source,typescript]
----
import {resetInheritance} from '/lib/xp/content';

// Resets all custom changes made to inherited item '/mySite/mycontent' in the layer 'layer-no'
resetInheritance({key: '/mySite/mycontent', projectName: 'layer-no', inherit: ['CONTENT', 'PARENT', 'NAME', 'SORT']});
----

[source,typescript]
----
import {resetInheritance} from '/lib/xp/content';

// Resets custom sorting of inherited item '/mySite/mycontent' in the layer 'layer-no', but preserves any other changes
resetInheritance({key: '/mySite/mycontent', projectName: 'layer-no', inherit: ['SORT']});
----

=== restore
image:xp-780.svg[XP 7.8.0,opts=inline]

Restores a content from the archive

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| content | string | Path or id of the content to be restored
| path | string | Path of parent for restored content
|===

[.lead]
Returns

*string[]* : List with ids of the contents that were restored

[.lead]
Examples
[source,typescript]
----
import {restore} from '/lib/xp/content';

// Restore content by path.
const result1 = restore({
    content: '/path/to/mycontent',
});

log.info('Restored content ids: %s', result1.join(','));

// Restore content by id.
const result2 = restore({
    content: 'my-content-id'
});

log.info('Restored content ids: %s', result2.join(','));

// Restore content by id to custom path.
const result3 = restore({
    content: 'my-content-id',
    path: '/custom-parent'
});

log.info('Restored content ids: %s', result3.join(','));
----

=== applyPermissions

Applies permissions on a content.

NOTE: If the content is published, the permissions will be applied to the published content as well without a need to republish it.
[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes | Description
| key | string | | Path or id of the content
| permissions | <<PermissionsParams>>[] | <optional> | Array of permissions to overwrite current permissions. Cannot be used with 'addPermissions' or 'removePermissions'
| addPermissions | <<PermissionsParams>>[] | <optional> | Array of permissions to add. Cannot be used simultaneously with 'permissions'
| removePermissions | <<PermissionsParams>>[] | <optional> | Array of permissions to remove. Cannot be used simultaneously with 'permissions'
| scope | string ('SINGLE' \| 'TREE' \| 'SUBTREE') | <optional>  | scope of applying permissions. Scope 'SINGLE' applies permissions only to the content itself. 'TREE' applies permissions to the content and its descendants. 'SUBTREE' applies permissions only to the content's descendants. Default is 'SINGLE'.
|===

[.lead]
Returns

*object* : The map <ContentId, Permissions> indicating for each content id which permissions were applied


[.lead]
Examples

.1) Applying permissions to a content by overwriting the current permissions.

[source,js]
----
repo.applyPermissions({
    key: '/my-content',
    permissions: [
        {
            principal: 'role:system.everyone',
            allow: ['READ']
        },
        {
            principal: 'user:system:my-user',
            allow: ['READ', 'CREATE', 'MODIFY', 'DELETE']
        }
    ]
});
----

.2) Adding permissions to a content.

[source,js]
----
repo.applyPermissions({
    key: '/my-content',
    addPermissions: [
        {
            principal: 'role:system.everyone',
            allow: ['CREATE', 'MODIFY']  // 'READ' permission is already set and will be kept.
        },
        {
            principal: 'user:system:my-new-user',
            allow: ['READ', 'CREATE', 'MODIFY', 'DELETE'] // New user will have all permissions.
        }
    ]
});
----

.3) Removing permissions from a content.

[source,js]
----
repo.applyPermissions({
    key: '/my-content',
    removePermissions: [
        {
            principal: 'role:system.everyone',
            allow: ['CREATE', 'MODIFY']  // 'READ' permission will be kept.
        },
        {
            principal: 'user:system:my-user',
            allow: ['DELETE'] // 'DELETE' permission will be removed. All other permissions will be kept.
        },
        {
            principal: 'user:system:my-new-user' // All permissions for this principal will be removed.
        }
    ]
});
----

.Applying permissions to a content and its descendants.

[source,js]
----
repo.applyPermissions({
    key: '/my-content',
    permissions: [
        {
            principal: 'role:system.everyone',
            allow: ['READ']
        }
    ],
    scope: 'TREE'
});
----

.Applying permissions to a content's descendants only.

[source,js]
----
repo.applyPermissions({
    key: '/my-content',
    permissions: [
        {
            principal: 'role:system.everyone',
            allow: ['READ']
        }
    ],
    scope: 'CHILDREN'
});
----

==== PermissionsParams

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| principal | string | Principal key
| allow | string[] | Allowed permissions
| deny | string[] | Denied permissions
|===

=== unpublish

Unpublishes content that had been published to the master branch

[.lead]
*Parameters:*

An object with the following keys and their values:

[%header,cols="1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Description
| keys | string[] | List of all content keys(path or id) that should be unpublished
|===

[.lead]
Returns

*string[]* : List with ids of the content that were unpublished

[.lead]
Examples

[source,typescript]
----
import {unpublish} from '/lib/xp/content';

// Unpublish content by path or key
const result = unpublish({
    keys: ['/mysite/somepage', '79e21db0-5b43-45ce-b58c-6e1c420b22bd']
});

log.info('Unpublished content ids: %s', result.join(','));
----

[source,typescript]
----
// Content unpublished.
const expected = [
    "d7ad428b-eae2-4ff1-9427-e8e8a8a3ab23",
    "9f5b0db0-38f9-4e81-b92e-116f25476b1c",
    "e1f57280-d672-4cd8-b674-98e26e5b69ae"
];
----

== Objects

=== ContentType

[.lead]
Fields

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| name | string | | Name of the content type
| displayName | string | | Display name of the content type
| description | string | | Description of the content type
| superType | string | | Name of the super type, or null if it has no super type
| abstract | boolean | | Whether or not content of this type may be instantiated
| final | boolean | | Whether or not it may be used as super type of other content types
| allowChildContent | boolean | | Whether or not allow creating child items on content of this type
| displayNameExpression | string | | ES6 string template for generating the content name based on values in the content form
| icon | <<IconType>> | <optional> | Icon of the content type
| form | object[] | | Form schema represented as an array of form items: Input, ItemSet, Layout, OptionSet
|===

=== IconType

[.lead]
Fields

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| data | object | <optional> | Stream with the binary data for the icon
| mimeType | string | <optional> | Mime type of the icon image
| modifiedTime | string | <optional> | Modified time of the icon. May be used for caching
|===

=== WorkflowInfoType

[.lead]
Fields

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| state | string |  | The name of the current workflow state (e.g., "IN_PROGRESS", "READY").
| checks | object | <optional> | A JSON object mapping specific check names (string) to their status (string). The status must be one of: `PENDING`, `REJECTED`, or `APPROVED`.
|===

=== ValidationErrorType

[.lead]
Fields

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| errorCode | string | | **Required.** The validation error code (e.g., `MISSING_REQUIRED`, `INVALID_FORMAT`).
| message | string | <optional> | A static, human-readable error message.
| i18n | string | <optional> | The i18n localization key for the error message.
| args | array | <optional> | An array of values to be substituted into the `i18n` message.
| attachment | string | <optional> | The name (or `BinaryReference` string) of the attachment this error relates to.
| propertyPath | string | <optional> | The `PropertyPath` (as a string) to the data field this error relates to (e.g., `mySet.0.myInput`).
|===


=== PageType

[.lead]
Fields

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| descriptor | string |  | The `DescriptorKey` (e.g., `com.myapp:my-page`) of the page controller.
| template | string | <optional> | The `PageTemplateKey` of the page template to use.
| config | object | <optional> | A JSON object (PropertyTree) for the page's configuration.
| regions | object | <optional> | An object mapping region names (string) to <<RegionType, RegionType objects>>.
| fragment | object | <optional> | A fragment component.
|===

=== RegionType

[.lead]
Fields

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| components | object[] | <optional> | An array of component objects (e.g., <<LayoutComponentType, Layout>>, <<PartComponentType, Part>>, etc.) placed within this region.
|===

=== LayoutComponentType

[.lead]
Fields

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| descriptor | string |  | The `DescriptorKey` (e.g., `com.myapp:2-column`) of the layout.
| config | object | <optional> | A JSON object for the layout's configuration.
| regions | object | <optional> | A <<RegionType, Regions object>> map containing the regions *within* this layout.
|===

=== PartComponentType

[.lead]
Fields

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| descriptor | string |  | The descriptor string (e.g., `com.myapp:my-part`) of the part.
| config | object | <optional> | A JSON object for the part's configuration.
|===

=== TextComponentType

[.lead]
Fields

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| text | string | <optional> | Text content of the component.
|===

=== ImageComponentType

[.lead]
Fields

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| image | string | <optional> | The `ContentId` (as a string) of the image content item.
| config | object | <optional> | A JSON object for the image's configuration.
|===

=== FragmentComponentType

[.lead]
Fields

[%header,cols="1%,1%,1%,98%a"]
[frame="none"]
[grid="none"]
|===
| Name | Type | Attributes| Description
| fragment | string | <optional> | The `ContentId` (as a string) of the fragment content item.
|===
